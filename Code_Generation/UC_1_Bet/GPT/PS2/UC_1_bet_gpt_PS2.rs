#![allow(unexpected_cfgs)]
use anchor_lang::prelude::*;
use anchor_lang::system_program;
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

declare_id!("3u7jbREqa2fnJBnTw3Cb5GFrcxw5fDauDDWXfm4dFRiu");

#[program]
pub mod bet_openai {
    use super::*;

    /// Both participants join in the same transaction, deposit wagers into PDA.
    pub fn join(ctx: Context<JoinCtx>, delay: u64, wager: u64) -> Result<()> {
        // --- Extract immutable values first ---
        let bet_info_key = ctx.accounts.bet_info.key();
        let bet_info_account = ctx.accounts.bet_info.to_account_info();

        let p1_key = ctx.accounts.participant1.key();
        let p2_key = ctx.accounts.participant2.key();

        // Use the bump generated by Anchor
        let bump = ctx.bumps.bet_info;

        // --- Prepare signer seeds for PDA ---
        let seeds: &[&[u8]] = &[
            p1_key.as_ref(),
            p2_key.as_ref(),
            &[bump],
        ];
        let signer_seeds = &[&seeds[..]];

        // --- Transfer wagers from participants to PDA ---
        invoke_signed(
            &system_instruction::transfer(&p1_key, &bet_info_key, wager),
            &[
                ctx.accounts.participant1.to_account_info(),
                bet_info_account.clone(),
                ctx.accounts.system_program.to_account_info(),
            ],
            signer_seeds,
        )?;

        invoke_signed(
            &system_instruction::transfer(&p2_key, &bet_info_key, wager),
            &[
                ctx.accounts.participant2.to_account_info(),
                bet_info_account.clone(),
                ctx.accounts.system_program.to_account_info(),
            ],
            signer_seeds,
        )?;

        // --- Mutably borrow bet_info and update state ---
        let bet = &mut ctx.accounts.bet_info;
        bet.participant1 = p1_key;
        bet.participant2 = p2_key;
        bet.oracle = ctx.accounts.oracle.key();
        bet.wager = wager;
        bet.deadline_slot = Clock::get()?.slot + delay;
        bet.resolved = false;
        bet.initialized = true;
        bet.bump = bump; // store the bump if needed for future CPI calls
        Ok(())
    }

pub fn win(ctx: Context<WinCtx>) -> Result<()> {
    // Extract AccountInfos and bump BEFORE mutable borrow
    let pda_account_info = ctx.accounts.bet_info.to_account_info();
    let winner_account_info = ctx.accounts.winner.to_account_info();
    let system_program_info = ctx.accounts.system_program.to_account_info();
    let bet_bump = ctx.accounts.bet_info.bump;

    let p1_key = ctx.accounts.participant1.key();
    let p2_key = ctx.accounts.participant2.key();
    let seeds: &[&[u8]] = &[p1_key.as_ref(), p2_key.as_ref(), &[bet_bump]];
    let signer_seeds = &[&seeds[..]];

    // Take mutable borrow only for state updates
    let bet = &mut ctx.accounts.bet_info;

    // Checks
    require!(ctx.accounts.oracle.is_signer, BetError::Unauthorized);
    require!(!bet.resolved, BetError::AlreadyResolved);

    let winner_key = ctx.accounts.winner.key();
    require!(
        winner_key == bet.participant1 || winner_key == bet.participant2,
        BetError::InvalidWinner
    );

    let rent = Rent::get()?;
    let available_lamports = pda_account_info
        .lamports()
        .saturating_sub(rent.minimum_balance(BetInfo::SIZE));
    require!(available_lamports > 0, BetError::InsufficientFunds);

    // Transfer
    invoke_signed(
        &system_instruction::transfer(
            &pda_account_info.key(),
            &winner_account_info.key(),
            available_lamports,
        ),
        &[
            pda_account_info.clone(),
            winner_account_info.clone(),
            system_program_info.clone(),
        ],
        signer_seeds,
    )?;

    // Mark resolved
    bet.resolved = true;

    Ok(())
}



    pub fn timeout(ctx: Context<TimeoutCtx>) -> Result<()> {
        // --- Extract immutable values first ---
        let bet_info_key = ctx.accounts.bet_info.key();
        let bet_info_account = ctx.accounts.bet_info.to_account_info();

        let p1_key = ctx.accounts.participant1.key();
        let p2_key = ctx.accounts.participant2.key();

        // --- Now borrow mutably ---
        let bet = &mut ctx.accounts.bet_info;

        require!(!bet.resolved, BetError::AlreadyResolved);

        let available = bet_info_account.lamports();

        // Return funds to participants
        let half = available / 2;

        let seeds: &[&[u8]] = &[
            p1_key.as_ref(),
            p2_key.as_ref(),
            &[bet.bump],
        ];
        let signer_seeds = &[&seeds[..]];

        // Send half to participant1
        invoke_signed(
            &system_instruction::transfer(&bet_info_key, &p1_key, half),
            &[
                bet_info_account.clone(),
                ctx.accounts.participant1.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
            signer_seeds,
        )?;

        // Send half to participant2
        invoke_signed(
            &system_instruction::transfer(&bet_info_key, &p2_key, half),
            &[
                bet_info_account.clone(),
                ctx.accounts.participant2.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
            signer_seeds,
        )?;

        bet.resolved = true;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct JoinCtx<'info> {
    /// CHECK:
    #[account(mut, signer)]
    pub participant1: AccountInfo<'info>,
    /// CHECK:
    #[account(mut, signer)]
    pub participant2: AccountInfo<'info>,
    /// CHECK: oracle pubkey is stored in state, no direct access
    pub oracle: AccountInfo<'info>,
    #[account(
        init,
        payer = participant1,
        space = 8 + BetInfo::SIZE,
        seeds = [participant1.key().as_ref(), participant2.key().as_ref()],
        bump
    )]
    pub bet_info: Account<'info, BetInfo>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WinCtx<'info> {
    /// CHECK: recipient of payout
    pub winner: UncheckedAccount<'info>,

    /// Oracle must sign
    #[account()]
    pub oracle: Signer<'info>,

    #[account(
        mut, // Must be mutable for lamport transfer
        seeds = [participant1.key().as_ref(), participant2.key().as_ref()],
        bump = bet_info.bump
    )]
    pub bet_info: Account<'info, BetInfo>,

    /// CHECK: for PDA derivation only
    pub participant1: UncheckedAccount<'info>,
    /// CHECK: for PDA derivation only
    pub participant2: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}


#[derive(Accounts)]
pub struct TimeoutCtx<'info> {
    #[account(mut)]
    pub participant1: SystemAccount<'info>,
    #[account(mut)]
    pub participant2: SystemAccount<'info>,
    #[account(
        mut,
        seeds = [participant1.key().as_ref(), participant2.key().as_ref()],
        bump = bet_info.bump
    )]
    pub bet_info: Account<'info, BetInfo>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct BetInfo {
    pub participant1: Pubkey,
    pub participant2: Pubkey,
    pub oracle: Pubkey,
    pub deadline_slot: u64,
    pub wager: u64,
    pub resolved: bool,
    pub initialized: bool,
    pub bump: u8,
}

impl BetInfo {
    pub const SIZE: usize = 32 + 32 + 32 + 8 + 8 + 1 + 1 + 1;
}

#[error_code]
pub enum BetError {
    #[msg("Missing participant signatures")]
    MissingParticipantSignature,
    #[msg("Oracle must sign")]
    MissingOracleSignature,
    #[msg("Bet already initialized")]
    AlreadyInitialized,
    #[msg("Bet not initialized")]
    NotInitialized,
    #[msg("Bet already resolved")]
    AlreadyResolved,
    #[msg("Deadline has already passed")]
    DeadlinePassed,
    #[msg("Deadline not yet reached")]
    DeadlineNotReached,
    #[msg("PDA bump not found")]
    BumpNotFound,
    #[msg("Insufficient funds in bet account")]
    InsufficientFunds,
    #[msg("Invalid winner specified")]
    InvalidWinner,
    #[msg("Caller is not authorized to perform this action")]
    Unauthorized, // <- Add this
    #[msg("Oracle account does not match the designated oracle")]
    InvalidOracle,  // <- Add this
}

